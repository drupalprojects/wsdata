<?php

/**
 * @file
 * Defines core functionality for web service powered fields
 */

define('WSFIELDS_DEBUG', variable_get('wsfields_debug', FALSE));

/**
 * Implements hook_permission().
 */
function wsfields_permission() {
  return array(
    'administer wsfields' =>  array(
      'title' => t('Administer Web Service Fields'),
      'description' => t('Perform administration tasks for Web Service Fields.'),
    ),
  );
}

/**
 *  Implements hook_menu().
 *
 * DEPRECATED
 */
function wsfields_menu() {
  $items = array();

  foreach (entity_get_info() as $entity_type => $entity_info) {
    if ($entity_info['fieldable']) {
      foreach ($entity_info['bundles'] as $bundle_name => $bundle_info) {
        if (isset($bundle_info['admin'])) {
          // Extract path information from the bundle.
          $path = $bundle_info['admin']['path'];
          // Different bundles can appear on the same path (e.g. %node_type and
          // %comment_node_type). To allow field_ui_menu_load() to extract the
          // actual bundle object from the translated menu router path
          // arguments, we need to identify the argument position of the bundle
          // name string ('bundle argument') and pass that position to the menu
          // loader. The position needs to be casted into a string; otherwise it
          // would be replaced with the bundle name string.
          if (isset($bundle_info['admin']['bundle argument'])) {
            $bundle_arg = $bundle_info['admin']['bundle argument'];
            $bundle_pos = (string) $bundle_arg;
          }
          else {
            $bundle_arg = $bundle_name;
            $bundle_pos = '0';
          }
          // This is the position of the %field_ui_menu placeholder in the
          // items below.
          $field_position = count(explode('/', $path)) + 1;

          // Extract access information, providing defaults.
          $access = array_intersect_key($bundle_info['admin'], drupal_map_assoc(array('access callback', 'access arguments')));
          $access += array(
            'access callback' => 'user_access',
            'access arguments' => array('administer wsfields'),
          );

          $items["$path/fields/%field_ui_menu/wsfield"] = array(
            'load arguments' => array($entity_type, $bundle_arg, $bundle_pos, '%map'),
            'title' => 'Web Service Settings',
            'page callback' => 'drupal_get_form',
            'page arguments' => array('wsfields_field_settings_form', $field_position),
            'type' => MENU_LOCAL_TASK,
            'file' => 'wsfields.admin.inc',
          ) + $access;
        }
      }
    }
  }
  //return $items;
}

/**
 * Implements hook_wsfields_FIELD_TYPE_data_alter().
 */
function wsfields_wsfields_text_data_alter($data, $field) {

  // Use the generalized data formater
  _wsfields_general_data_alter($data, $field);

  return $data;
}

/**
 * Implements hook_wsfields_FIELD_TYPE_data_alter().
 */
function wsfields_wsfields_text_with_summary_data_alter($data, $field) {

  // Use the generalized data formater
  _wsfields_general_data_alter($data, $field);

  $formats = array_keys(filter_formats());
  if (sizeof($formats) > 0) {
    $formats = $formats[0];
    foreach($data as $lang => $values) {
      foreach ($values as $id => $field) {
        $data[$lang][$id]['format'] = $formats;
      }
    }
  }
  return $data;
}

/**
 * Implements hook_wsfields_FIELD_TYPE_data_alter().
 */
function wsfields_wsfields_text_long_data_alter($data, $field) {

  // Use the generalized data formater
  _wsfields_general_data_alter($data, $field);

  return $data;
}

/**
 * Implements hook_wsfields_FIELD_TYPE_data_alter().
 */
function wsfields_wsfields_number_decimal_data_alter($data, $field) {

  // Use the generalized data formater
  _wsfields_general_data_alter($data, $field);

  return $data;
}

/**
 * Implements hook_wsfields_FIELD_TYPE_data_alter().
 */
function wsfields_wsfields_number_float_data_alter($data, $field) {

  // Use the generalized data formater
  _wsfields_general_data_alter($data, $field);

  return $data;
}

/**
 * Implements hook_wsfields_FIELD_TYPE_data_alter().
 */
function wsfields_wsfields_number_integer_data_alter($data, $field) {

  // Use the generalized data formater
  _wsfields_general_data_alter($data, $field);

  return $data;
}

/**
 * Implements hook_wsfields_FIELD_TYPE_data_alter().
 */
function wsfields_wsfields_list_boolean_data_alter($data, $field) {

  // Use the generalized data formater
  _wsfields_general_data_alter($data, $field);

  return $data;
}

/**
 * Implements hook_wsfields_FIELD_TYPE_data_alter().
 */
function wsfields_wsfields_list_float_data_alter($data, $field) {

  // Use the generalized data formater
  _wsfields_general_data_alter($data, $field);

  return $data;
}

/**
 * Implements hook_wsfields_FIELD_TYPE_data_alter().
 */
function wsfields_wsfields_list_integer_data_alter($data, $field) {

  // Use the generalized data formater
  _wsfields_general_data_alter($data, $field);

  return $data;
}

/**
 * Implements hook_wsfields_FIELD_TYPE_data_alter().
 */
function wsfields_wsfields_list_text_data_alter($data, $field) {

  // Use the generalized data formater
  _wsfields_general_data_alter($data, $field);

  return $data;
}

/**
 * General data alter function for fields
 *
 * Fields which have a basic field format can use this to properly
 * build out their field instance arrays
 *
 * @param array $data [reference]
 *  Data array
 * @param array $field [reference]
 *  Field instance
 * @param array $field [optionstal]
 *  Field settings
 */
function _wsfields_general_data_alter(&$data, &$field) {
  // Build the field array as required
  if (!is_array($data)) {
    $field_data[LANGUAGE_NONE][] = array('value' => $data);
  }
  else {
    /*
      If the field contains translated data, the field values should be structured like this:
      [language1][0] = data1
      [language1][1] = data2
      [language2][0] = data1
      [language2][1] = data2
    */
    if ($field['storage']['settings']['translated']) {
      foreach($data as $language => $values) {
        foreach ($values as $value) {
          $field_data[$language][] = array('value' => $value);
        }
      }
    } else {
      foreach($data as $value) {
        $field_data[LANGUAGE_NONE][] = array('value' => $value);
      }
    }
  }

  // Save the new field data
  $data = $field_data;
}

/**
 * Perform Service Request
 *
 * @param string $entity_type
 *  Machine name of a given entity type
 * @param array $field
 *  Field definition to load data into
 * @param object $entity
 *  Entity object
 * @return array|boolean
 *  Returns the formatted field data, FALSE otherwise.
 */
function wsfields_data_load($entity_type, $field, $entity) {
  if (WSFIELDS_DEBUG) debug("WSFields loading " . $entity->type . "->" . $field['field_name'] . " of type " . $field['type']);

  if (!isset($field['storage']['settings']['wsconfig_name'])) {
    if (WSFIELDS_DEBUG) debug("wsconfig_name not set, wsfield cannot continue.");
    return FALSE;
  }

  // Load required settings from the field instance
  $wsconfig_name = $field['storage']['settings']['wsconfig_name'];
  $remotename = $field['storage']['settings']['remotekey'];
  $processor = $field['storage']['settings']['processor'];
  $propertymap = $field['storage']['settings']['propertymap']['read'];
    
  // Load the web service configuration
  $wsconfig = wsconfig_load_by_name($wsconfig_name);

  if (!is_object($wsconfig)) {
    if (WSFIELDS_DEBUG) debug("Couldn't find wsconfig: " . $wsconfig_name);
    return FALSE;
  } else {
    // Get the method name for token replacement
    $remotemethod = $wsconfig->data['read_data_method'];

    // Replace the tokens in the "read" pattern with entity property values
    $remotekeys = array();
    $ws_keys = array();
    if ( isset($entity->ws_keys) and !empty($entity->ws_keys)) {
      $ws_keys = unserialize($entity->ws_keys);
    }

    foreach ($propertymap as $pattern => $entity_property) {
      // If we don't have a value for a key, exit since we will not be able to resolve the data
      $value = FALSE;
      if (isset($ws_keys[$entity_property])) {
        $value = $ws_keys[$entity_property];
      } elseif (isset($entity->$entity_property) and !empty($entity->$entity_property)) {
        $value = $entity->$entity_property;
      } else {
        if (WSFIELDS_DEBUG) debug("Couldn't find pattern: " . $pattern);
        return FALSE;
      }

      // Replace the placeholders in the URL pattern with values from property key map
      $remotemethod = str_replace($pattern, $value, $remotemethod);
    }

    if (!class_exists($processor)) {
      watchdog('wsfields', 'Web service fields cannot create class @processor. Class not found.', array('@processor' => $processor), WATCHDOG_ERROR);
      drupal_set_message(t("Unable to build data processor. See logs for more details."), 'error', FALSE);
      return FALSE;
    }

    // Create a new processor
    $processor = new $processor(array(), $entity);

    // Check the subclass of the processor
    if (!is_subclass_of($processor, 'WsData')) {
      drupal_set_message(t("Unable to build data processor. See logs for more details"), 'error', FALSE);
      watchdog('wsfields', " Unable to create web service processor. Class @class isn't a sub class of WsData", array('@class' => $processor), WATCHDOG_ERROR);
      return FALSE;
    }

    // Attempt the connection
    if ($wsconfig->connector) {
      // Load the list of accepted data formats
      $type = $processor->accepts();

      // Select the first option
      // @todo come up with a way for the objects to decide which accept type it should use
      $type = array_pop($type);

      // Read the data
      $data = $wsconfig->connector->read($remotemethod, $remotekeys, array('accept-type' => $type));

      $processor->addData($data);

      // Load the requested data
      $data = $processor->getData($remotename);

      // Build the field format
      if (!is_null($data) && FALSE !== $data) {
        $data = module_invoke_all('wsfields_' . $field['type'] . '_data_alter', $data, $field);

        // Display debug information if required
        if (WSFIELDS_DEBUG) {
          if (!drupal_is_cli()) {
            dpm($data);
          }
        }
        return $data;
      }
    }
  }
}
