<?php

/**
 * @file
 * Defines core functionality for web service powered fields
 */

define('WSFIELDS_DEBUG', variable_get('wsfields_debug', FALSE));

/**
 * Implements hook_permission().
 */
function wsfields_permission() {
  return array(
    'administer wsfields' =>  array(
      'title' => t('Administer Web Service Fields'),
      'description' => t('Perform administration tasks for Web Service Fields.'),
    ),
  );
}

/**
 *  Implements hook_menu().
 */
function wsfields_menu() {
  $items = array();

  foreach (entity_get_info() as $entity_type => $entity_info) {
    if ($entity_info['fieldable']) {
      foreach ($entity_info['bundles'] as $bundle_name => $bundle_info) {
        if (isset($bundle_info['admin'])) {
          // Extract path information from the bundle.
          $path = $bundle_info['admin']['path'];
          // Different bundles can appear on the same path (e.g. %node_type and
          // %comment_node_type). To allow field_ui_menu_load() to extract the
          // actual bundle object from the translated menu router path
          // arguments, we need to identify the argument position of the bundle
          // name string ('bundle argument') and pass that position to the menu
          // loader. The position needs to be casted into a string; otherwise it
          // would be replaced with the bundle name string.
          if (isset($bundle_info['admin']['bundle argument'])) {
            $bundle_arg = $bundle_info['admin']['bundle argument'];
            $bundle_pos = (string) $bundle_arg;
          }
          else {
            $bundle_arg = $bundle_name;
            $bundle_pos = '0';
          }
          // This is the position of the %field_ui_menu placeholder in the
          // items below.
          $field_position = count(explode('/', $path)) + 1;

          // Extract access information, providing defaults.
          $access = array_intersect_key($bundle_info['admin'], drupal_map_assoc(array('access callback', 'access arguments')));
          $access += array(
            'access callback' => 'user_access',
            'access arguments' => array('administer wsfields'),
          );

          $items["$path/fields/%field_ui_menu/wsfield"] = array(
            'load arguments' => array($entity_type, $bundle_arg, $bundle_pos, '%map'),
            'title' => 'Web Service Settings',
            'page callback' => 'drupal_get_form',
            'page arguments' => array('wsfields_field_settings_form', $field_position),
            'type' => MENU_LOCAL_TASK,
            'file' => 'wsfields.admin.inc',
          ) + $access;
        }
      }
    }
  }
  return $items;
}

/**
 * Implements hook_field_storage_pre_load().
 */
function wsfields_field_storage_pre_load($entity_type, &$entities, $age, &$skip_fields, $options) { 
  $instances = _wsfields_field_info_instances($entity_type);
  $entityinfo = entity_get_info($entity_type);
  $bundlefield = $entityinfo['entity keys']['bundle'];

  foreach ($instances as $bundlename => $bundle) {
    foreach ($bundle as $instance_name => $instance) {
      $skip_fields[$instance['field_id']] = TRUE;

      foreach ($entities as $entityid => $entity) {
        if (isset($bundlefield) and !empty($bundlefield) and $entity->$bundlefield =! $bundlename) {
           continue; // Skip this, it wasn't the right bundle
        }

        $data = _wsfields_data_load($entity_type, $instance, $entity);
        // Add the default empty field array
        // @see http://api.drupal.org/api/drupal/modules!field!field.api.php/function/hook_field_storage_pre_load/7
        $entities[$entityid]->$instance_name = array();
        // Check if data is returned
        // Need to be specific on the data checking since certain empty
        // values may be considered valid. Only NULL and FALSE are omited
        if (!is_null($data) && FALSE !== $data) {
//          dpm(array('wsfields_' . $instance['field_info']['type'] . '_data_alter', $data, $instance));
          $data = module_invoke_all('wsfields_' . $instance['field_info']['type'] . '_data_alter', $data, $instance);
          // Display debug information if required
          if (WSFIELDS_DEBUG) {
            dpm($data);
          }

          $entities[$entityid]->$instance_name = $data;
        }
      }
    }
  }
}

/**
 * Implements hook_field_storage_pre_insert().
 */
function wsfields_field_storage_pre_insert($entity_type, $entity, &$skip_fields) {
  $instances = _wsfields_field_info_instances($entity_type);

  foreach ($instances as $bundle) {
    foreach ($bundle as $instance_name => $instance) {
    $skip_fields[$instance['field_id']] = TRUE;
    }
  }
}

/**
 * Implements hook_wsfields_FIELD_TYPE_data_alter().
 */
function wsfields_wsfields_text_data_alter($data, $instance) {
  
  // Use the generalized data formater
  _wsfields_general_data_alter($data, $instance);
  
  return $data;
}

/**
 * Implements hook_wsfields_FIELD_TYPE_data_alter().
 */
function wsfields_wsfields_text_with_summary_data_alter($data, $instance) {
  
  // Use the generalized data formater
  _wsfields_general_data_alter($data, $instance);
  
  return $data;
}

/**
 * Implements hook_wsfields_FIELD_TYPE_data_alter().
 */
function wsfields_wsfields_text_long_data_alter($data, $instance) {
  
  // Use the generalized data formater
  _wsfields_general_data_alter($data, $instance);
  
  return $data;
}

/**
 * Implements hook_wsfields_FIELD_TYPE_data_alter().
 */
function wsfields_wsfields_number_decimal_data_alter($data, $instance) {

  // Use the generalized data formater
  _wsfields_general_data_alter($data, $instance);
  
  return $data;
}

/**
 * Implements hook_wsfields_FIELD_TYPE_data_alter().
 */
function wsfields_wsfields_number_float_data_alter($data, $instance) {

  // Use the generalized data formater
  _wsfields_general_data_alter($data, $instance);
  
  return $data;
}

/**
 * Implements hook_wsfields_FIELD_TYPE_data_alter().
 */
function wsfields_wsfields_number_integer_data_alter($data, $instance) {

  // Use the generalized data formater
  _wsfields_general_data_alter($data, $instance);
  
  return $data;
}

/**
 * Implements hook_wsfields_FIELD_TYPE_data_alter().
 */
function wsfields_wsfields_list_boolean_data_alter($data, $instance) {

  // Use the generalized data formater
  _wsfields_general_data_alter($data, $instance);
  
  return $data;
}

/**
 * Implements hook_wsfields_FIELD_TYPE_data_alter().
 */
function wsfields_wsfields_list_float_data_alter($data, $instance) {

  // Use the generalized data formater
  _wsfields_general_data_alter($data, $instance);
  
  return $data;
}

/**
 * Implements hook_wsfields_FIELD_TYPE_data_alter().
 */
function wsfields_wsfields_list_integer_data_alter($data, $instance) {

  // Use the generalized data formater
  _wsfields_general_data_alter($data, $instance);
  
  return $data;
}

/**
 * Implements hook_wsfields_FIELD_TYPE_data_alter().
 */
function wsfields_wsfields_list_text_data_alter($data, $instance) {

  // Use the generalized data formater
  _wsfields_general_data_alter($data, $instance);
  
  return $data;
}

/**
 * General data alter function for fields
 *
 * Fields which have a basic field format can use this to properly
 * build out their field instance arrays
 *
 * @param array $data [reference]
 *  Data array
 * @param array $instance [reference]
 *  Field instance
 */
function _wsfields_general_data_alter(&$data, &$instance) {
  // Build the field array as required
  if (!is_array($data)) {
    $field_data[LANGUAGE_NONE][] = array('value' => $data);
  }
  else {
    /*
      If the field contains translated data, the field values should be structured like this:
      [language1][0] = data1
      [language1][1] = data2
      [language2][0] = data1
      [language2][1] = data2
    */
    if (isset($instance['settings']['wsfield_translated']) and $instance['settings']['wsfield_translated']) {
      foreach($data as $language => $values) {
        foreach ($values as $value) {
          $field_data[$language][] = $value;
        }
      }
    } else {
      foreach($data as $value) {
        $field_data[LANGUAGE_NONE][] = array('value' => $value);
      }
    }
  }

  // Save the new field data
  $data = $field_data;
}

/**
 * Get the names and ids of field instances that are defined as web service
 * fields
 *
 * @param string $entity_type
 *  Machine name of the entity
 * @return array
 *  Returns the instance info for the given entity fields
 */
function _wsfields_field_info_instances($entity_type) {
  $instances = field_info_instances($entity_type);

  foreach($instances as $bundlename => $bundle) {
    foreach ($instances[$bundlename] as $name => $instance) {
      if (isset($instance['settings']) and isset($instance['settings']['wsfield']) and $instance['settings']['wsfield']) {
        // Add information about the field type for use later during data
        // processing
        $instances[$bundlename][$name]['field_info'] = field_info_field($name);
      }
      else {
        unset($instances[$bundlename][$name]);
      }
    }
  }
  return $instances;
}

/**
 * Perform Service Request
 *
 * @param string $entity_type
 *  Machine name of a given entity type
 * @param array $instance
 *  Instance info array for the given field
 * @param object $entity
 *  Entity object
 * @return array|boolean
 *  Returns the formatted field data, FALSE otherwise.
 */
function _wsfields_data_load($entity_type, $instance, $entity) {
  
  if (!isset($instance['settings']['wsfield_configset'])) {
    return FALSE;
  }

  // Load required settings from the field instance
  $wsconfigid = $instance['settings']['wsfield_configset'];
  $wsremotename = $instance['settings']['wsfield_remotename'];
  $wsprocessor = $instance['settings']['wsfield_processor'];
  $wsproperty = $instance['settings']['wsfield_property'];
  $wspropertytokens = isset($instance['settings']['wsfield_property_tokens'])? $instance['settings']['wsfield_property_tokens'] : array();
  
  $wsconfig = wsconfig_load($wsconfigid);

  // Check if the web service is enabled
  if (!isset($wsproperty)) {
    return FALSE;
  }

  // Replace any tokens
  $remotekeys = array();
  foreach ($wsproperty as $p) {
    // If we don't have a value for a key, exit since we will not be able to resolve the data
    if (!isset($entity->$p) or empty($entity->$p)) {
      return FALSE;
    }
    $remotekeys[$p] = token_replace("[$entity_type:$p]", array($entity_type => $entity));
  }
 
  // Replace the tokens in the method name
  $remotemethod = $wsconfig->data['read_data_method'];
  foreach ($wspropertytokens as $prop => $token) {
    $remotemethod = str_replace($token, $remotekeys[$prop], $remotemethod);
    unset($remotekeys[$prop]);
  }

  if (!class_exists($wsprocessor)) {
    watchdog('wsfields', 'Web service fields cannot create class @wsprocessor. Class not found.', array('@wsprocessor' => $wsprocessor), WATCHDOG_ERROR);
    drupal_set_message(t("Unable to build data processor. See logs for more details."), 'error', FALSE);
    return FALSE;
  }

  // Create a new processor
  $processor = new $wsprocessor();

  // Check the subclass of the processor
  if (!is_subclass_of($processor, 'WsData')) {
    drupal_set_message(t("Unable to build data processor. See logs for more details"), 'error', FALSE);
    watchdog('wsfields', " Unable to create web service processor. Class @class isn't a sub class of WsData", array('@class' => $wsprocessor), WATCHDOG_ERROR);
    return FALSE;
  }

  // Attempt the connection
  if ($wsconfig->connector) {
    // Load the list of accepted data formats
    $type = $processor->accepts();

    // Select the first option
    // @todo come up with a way for the objects to decide which accept type it should use
    $type = array_pop($type);

    // Read the data
    $data = $wsconfig->connector->read($remotemethod, $remotekeys, array('accept-type' => $type));
    $processor->addData($data);

    // Load the requested data
    return $processor->getData($wsremotename, $instance, $entity);
  }
  return FALSE;
}
